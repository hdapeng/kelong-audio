<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³ç”Ÿæˆ</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* è‡ªå®šä¹‰Interå­—ä½“ (Tailwindé»˜è®¤) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        /* åŠ è½½ä¸­åŠ¨ç”» */
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4 relative">

    <!-- ç‰ˆæœ¬åˆ‡æ¢æ§ä»¶ -->
    <div class="absolute top-4 right-4">
        <select id="version-select"
            class="bg-white border border-gray-300 text-gray-700 py-2 px-3 rounded shadow-sm text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer hover:bg-gray-50 transition">
            <option value="1.0">v1.0 ç¨³å®šç‰ˆ</option>
            <option value="1.1">v1.1 å¼€å‘ç‰ˆ</option>
        </select>
    </div>

    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-2xl space-y-6">

        <!-- æ ‡é¢˜ -->
        <h1 class="text-2xl font-bold text-center text-gray-800">
            è¯­éŸ³ç”Ÿæˆ
        </h1>

        <!-- (input) æ–‡æœ¬è¾“å…¥ -->
        <div>
            <label for="input-text" class="block text-sm font-medium text-gray-700 mb-1">
                Input (è¦è½¬æ¢çš„æ–‡æœ¬):
            </label>
            <textarea id="input-text" rows="5"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"
                placeholder="è¯·è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬..."></textarea>
            <div class="flex justify-between items-center mt-1">
                <span id="text-length" class="text-xs text-gray-500">0 å­—ç¬¦</span>
                <span class="text-xs text-gray-500">æ— å­—ç¬¦é™åˆ¶</span>
            </div>
        </div>

        <!-- (prompt_audio_url) æç¤ºéŸ³é¢‘ URL -->
        <div>
            <label for="input-prompt-audio-url" class="block text-sm font-medium text-gray-700 mb-1">
                Prompt Audio (ä»…æ”¯æŒ URL):
            </label>
            <input type="text" id="input-prompt-audio-url"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"
                placeholder="https://... (å¿…é¡»æ˜¯å¯å…¬å¼€è®¿é—®çš„ URL)">
            <p class="text-xs text-gray-500 mt-1">
                <strong>æ³¨æ„:</strong> æ­¤å­—æ®µå¿…é¡»æ˜¯å¯å…¬å¼€è®¿é—®çš„ URL (ä¾‹å¦‚ <code>https://...</code>)ã€‚
                <strong>ä¸æ”¯æŒæœ¬åœ°æ–‡ä»¶ä¸Šä¼ ã€‚</strong> æ¨èä½¿ç”¨ <code>.wav</code> æ ¼å¼ã€‚
            </p>
        </div>

        <!-- (prompt_text) æç¤ºæ–‡æœ¬ -->
        <div>
            <label for="input-prompt-text" class="block text-sm font-medium text-gray-700 mb-1">
                Prompt Text (å¯é€‰):
            </label>
            <textarea id="input-prompt-text" rows="3"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"
                placeholder="æç¤ºéŸ³é¢‘å¯¹åº”çš„æ–‡æœ¬..."></textarea>
        </div>

        <!-- (remark) å¤‡æ³¨ -->
        <div>
            <label for="input-remark" class="block text-sm font-medium text-gray-700 mb-1">
                å¤‡æ³¨ (å¯é€‰):
            </label>
            <input type="text" id="input-remark"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"
                placeholder="ä¸ºæ­¤ä»»åŠ¡æ·»åŠ å¤‡æ³¨...">
        </div>

        <!-- ç”ŸæˆæŒ‰é’® -->
        <button id="generate-btn"
            class="w-full bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 flex items-center justify-center">
            <span id="btn-text">ç”Ÿæˆè¯­éŸ³</span>
            <div id="btn-status-container" class="flex items-center hidden">
                <div id="btn-loader"
                    class="loader ease-linear rounded-full border-4 border-t-4 border-white h-5 w-5 mr-2"></div>
                <span id="btn-status-text"></span>
            </div>
        </button>

        <!-- ç­‰å¾…æ—¶é—´æ˜¾ç¤º -->
        <div id="wait-time" class="text-center text-sm text-gray-500 h-5 hidden"></div>

        <!-- çŠ¶æ€/é”™è¯¯æ¶ˆæ¯ (ä¿æŒç”¨äºæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯) -->
        <div id="status-msg" class="text-center text-red-500 h-5" role="alert"></div>

        <!-- éŸ³é¢‘æ’­æ”¾å™¨ -->
        <div id="audio-container" class="hidden">
            <label class="block text-sm font-medium text-gray-700 mb-1">
                ç”Ÿæˆç»“æœ:
            </label>
            <audio id="audio-player" controls class="w-full">
                <source src="" type="audio/mpeg">
                æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ audio å…ƒç´ ã€‚
            </audio>
            <div id="compute-time" class="text-center text-sm text-gray-500 mt-2"></div>
        </div>
    </div>

    <!-- ä¾§è¾¹æ  (ä»… v1.1 æ˜¾ç¤º) -->
    <div id="sidebar-toggle-btn"
        class="hidden fixed top-1/2 right-0 transform -translate-y-1/2 z-40 bg-white p-2 rounded-l-lg shadow-md cursor-pointer hover:bg-gray-50 transition border border-gray-200 border-r-0"
        onclick="document.getElementById('task-sidebar').classList.remove('hidden'); setTimeout(()=>document.getElementById('task-sidebar').classList.remove('translate-x-full'), 10)">
        <span class="text-xl">ğŸ“œ</span>
    </div>

    <aside id="task-sidebar"
        class="hidden fixed top-0 right-0 h-full w-80 bg-white shadow-2xl z-50 transform translate-x-full transition-transform duration-300 flex flex-col">
        <!-- ä¾§è¾¹æ å¤´éƒ¨ -->
        <div class="p-4 border-b border-gray-200 bg-gray-50">
            <div class="flex justify-between items-center mb-2">
                <h2 class="text-lg font-bold text-gray-800">ğŸ“œ ä»»åŠ¡å†å²</h2>
                <button
                    onclick="document.getElementById('task-sidebar').classList.add('translate-x-full'); setTimeout(()=>document.getElementById('task-sidebar').classList.add('hidden'), 300)"
                    class="text-gray-500 hover:text-gray-700">
                    âœ–ï¸
                </button>
            </div>
            <!-- æ‰¹é‡æ“ä½œå·¥å…·æ  -->
            <div class="flex items-center justify-between text-xs">
                <label class="flex items-center space-x-1 cursor-pointer">
                    <input type="checkbox" id="select-all-tasks"
                        class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                    <span class="text-gray-600">å…¨é€‰</span>
                </label>
                <button id="bulk-delete-btn"
                    class="text-red-600 hover:text-red-800 disabled:text-gray-300 disabled:cursor-not-allowed" disabled>
                    ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤
                </button>
            </div>
        </div>

        <!-- ä»»åŠ¡åˆ—è¡¨å®¹å™¨ -->
        <div id="task-list" class="flex-1 overflow-y-auto p-4 space-y-4">
            <!-- åŠ¨æ€ç”Ÿæˆçš„å†…å®¹ -->
        </div>
    </aside>

    <!-- Confirm Delete Modal -->
    <div id="delete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center"
        style="z-index: 9999;">
        <div class="bg-white rounded-lg p-6 w-80 shadow-2xl transform transition-all">
            <h3 class="text-lg font-bold text-gray-800 mb-2">ç¡®è®¤åˆ é™¤?</h3>
            <p id="delete-modal-msg" class="text-gray-600 text-sm mb-6">æ‚¨ç¡®å®šè¦åˆ é™¤æ­¤ä»»åŠ¡å—ï¼Ÿ</p>
            <div class="flex justify-end space-x-3">
                <button onclick="window.closeDeleteModal()"
                    class="px-4 py-2 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition text-sm">
                    å–æ¶ˆ
                </button>
                <button id="confirm-delete-btn" onclick="window.performDelete()"
                    class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition text-sm">
                    åˆ é™¤
                </button>
            </div>
        </div>
    </div>

    <script src="db.js"></script>
    <script>
        // ç‰ˆæœ¬æ§åˆ¶é€»è¾‘
        const versionSelect = document.getElementById('version-select');
        const urlParams = new URLSearchParams(window.location.search);
        const currentVersion = urlParams.get('version') || '1.0';
        window.CURRENT_VERSION = currentVersion; // æš´éœ²å…¨å±€å˜é‡

        // åˆå§‹åŒ–ä¸‹æ‹‰èœå•çŠ¶æ€
        versionSelect.value = currentVersion;

        // ç›‘å¬ç‰ˆæœ¬åˆ‡æ¢
        versionSelect.addEventListener('change', (e) => {
            const newVersion = e.target.value;
            const url = new URL(window.location);
            url.searchParams.set('version', newVersion);
            window.location.href = url.toString();
        });

        // ä»…åœ¨ v1.1 æ˜¾ç¤ºå¼€å‘ç‰ˆæç¤º (åç»­å°†åœ¨æ­¤å¤„åˆ†æµé€»è¾‘)
        if (currentVersion === '1.1') {
            console.log("Running in v1.1 Development Mode");
            document.title = "è¯­éŸ³ç”Ÿæˆ (v1.1 Dev)";
        }

        // API é…ç½®
        let API_KEY = "";
        const DEFAULT_API_URL = "https://ai.gitee.com/v1/audio/speech";
        const params = new URLSearchParams(window.location.search);
        const apiParam = params.get("api") || "";
        if (apiParam) { try { localStorage.setItem("API_URL_OVERRIDE", apiParam); } catch (e) { } }
        const API_URL_OVERRIDE = apiParam || localStorage.getItem("API_URL_OVERRIDE") || "";
        const PROD_DEFAULT_API_URL = (location.hostname.endsWith('github.io') || location.hostname === 'localhost' || location.hostname === '127.0.0.1' ? 'https://old-hat-f15f.qqa199388.workers.dev/audio/speech' : DEFAULT_API_URL);
        const API_URL = API_URL_OVERRIDE || PROD_DEFAULT_API_URL;
        const LAST_URL_KEY = "gitee_tts_last_prompt_url";
        const AUDIO_URLS_KEY = "gitee_tts_audio_urls"; // å­˜å‚¨éŸ³é¢‘URLå’Œæ—¶é—´æˆ³çš„é”®
        const AUDIO_EXPIRY_TIME = 24 * 60 * 60 * 1000; // 24å°æ—¶ï¼Œå•ä½ï¼šæ¯«ç§’

        // åŠ è½½APIå¯†é’¥ï¼ˆç•™ç©ºï¼Œä½¿ç”¨åç«¯ä»£ç†æ³¨å…¥ï¼‰
        async function loadApiKey() { }

        // --- åˆå§‹åŒ– --- (é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œ)
        document.addEventListener('DOMContentLoaded', async () => {
            // DOM å…ƒç´  (åœ¨DOMåŠ è½½å®Œæˆåè·å–)
            const inputText = document.getElementById('input-text');
            const inputPromptAudioUrl = document.getElementById('input-prompt-audio-url');
            const inputPromptText = document.getElementById('input-prompt-text');

            const generateBtn = document.getElementById('generate-btn');
            const btnText = document.getElementById('btn-text');
            const btnStatusContainer = document.getElementById('btn-status-container');
            const btnLoader = document.getElementById('btn-loader');
            const btnStatusText = document.getElementById('btn-status-text');

            const statusMsg = document.getElementById('status-msg');
            const waitTimeDisplay = document.getElementById('wait-time');
            const audioContainer = document.getElementById('audio-container');
            const audioPlayer = document.getElementById('audio-player');
            const textLengthIndicator = document.getElementById('text-length');
            const computeTimeDisplay = document.getElementById('compute-time');

            // æ£€æŸ¥å…³é”®DOMå…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!inputText || !textLengthIndicator || !generateBtn) {
                console.error('å…³é”®DOMå…ƒç´ æœªæ‰¾åˆ°:', {
                    inputText: !!inputText,
                    textLengthIndicator: !!textLengthIndicator,
                    generateBtn: !!generateBtn
                });
                return;
            }

            await loadApiKey();

            // è½®è¯¢ç®¡ç† map (æå‰åˆå§‹åŒ–)
            const activePolls = new Set();
            window.lastSubmittedTaskId = null;

            // v1.1 DB åˆå§‹åŒ–ä¸ UI æ¸²æŸ“
            if (window.CURRENT_VERSION === '1.1') {
                if (window.dbLayer) {
                    try {
                        await window.dbLayer.initDB();
                        console.log("DB Initialized for v1.1");

                        await window.dbLayer.clearExpiredTasks();
                        console.log("Expired tasks cleaned");

                        // æ¸²æŸ“ä¾§è¾¹æ 
                        await renderTaskList(); // ç¡®ä¿æ¸²æŸ“å®Œæˆ

                        // æ¢å¤è½®è¯¢ (é’ˆå¯¹ pending/running ä»»åŠ¡)
                        const tasks = await window.dbLayer.getTasks();
                        let resumeCount = 0;
                        for (const task of tasks) {
                            if (task.status === 'pending' || task.status === 'running' || task.status === 'in_progress') {
                                // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦è¿‡æœŸå¤ªä¹…ï¼Œé¿å…æ— é™è½®è¯¢æ—§ä»»åŠ¡
                                // å‡è®¾è¶…è¿‡ 30 åˆ†é’Ÿçš„ä»»åŠ¡å¯èƒ½å·²ç»ä¸å†éœ€è¦é«˜é¢‘è½®è¯¢ï¼Œæˆ–è€…å·²ç»è¢«æœåŠ¡ç«¯ä¸¢å¼ƒ
                                // ä½†æ ¹æ®éœ€æ±‚ï¼Œæˆ‘ä»¬è¿˜æ˜¯å°è¯•æ¢å¤è½®è¯¢ï¼ŒstartPolling å†…éƒ¨æœ‰è¶…æ—¶æœºåˆ¶
                                startPolling(task.id);
                                resumeCount++;
                            }
                        }
                        if (resumeCount > 0) {
                            console.log(`Resumed polling for ${resumeCount} tasks`);
                        }
                    } catch (err) {
                        console.error("DB Init/Render failed:", err);
                    }
                }
            }

            if (!API_KEY && API_URL === DEFAULT_API_URL) {
                showError("è¯·é…ç½®ä»£ç†åœ°å€æˆ–åœ¨æœåŠ¡ç«¯æ³¨å…¥å¯†é’¥");
            }

            // æ·»åŠ æ–‡æœ¬è¾“å…¥äº‹ä»¶ç›‘å¬å™¨ (åœ¨åˆå§‹åŒ–å‰æ·»åŠ )
            inputText.addEventListener('input', updateTextLength);

            // åˆå§‹åŒ–æ–‡æœ¬é•¿åº¦æŒ‡ç¤ºå™¨
            updateTextLength();

            // åŒæ—¶æ·»åŠ å…¶ä»–äº‹ä»¶ç›‘å¬å™¨ç¡®ä¿å®æ—¶æ›´æ–°
            inputText.addEventListener('keyup', updateTextLength);
            inputText.addEventListener('paste', () => {
                // å»¶è¿Ÿä¸€ä¸‹ï¼Œç¡®ä¿ç²˜è´´å†…å®¹å·²ç»æ’å…¥
                setTimeout(updateTextLength, 10);
            });

            // æ›´æ–°æ–‡æœ¬é•¿åº¦æŒ‡ç¤ºå™¨
            function updateTextLength() {
                // ç¡®ä¿å…ƒç´ å­˜åœ¨
                if (!inputText || !textLengthIndicator) {
                    console.warn('æ–‡æœ¬è¾“å…¥æ¡†æˆ–é•¿åº¦æŒ‡ç¤ºå™¨å…ƒç´ æœªæ‰¾åˆ°');
                    return;
                }

                const length = inputText.value.length;
                textLengthIndicator.textContent = `${length} å­—ç¬¦`;

                // æ ¹æ®é•¿åº¦æ”¹å˜é¢œè‰² (ä»…ä½œä¸ºå‚è€ƒ)
                if (length > 1000) {
                    textLengthIndicator.classList.remove('text-gray-500');
                    textLengthIndicator.classList.add('text-orange-500');
                } else {
                    textLengthIndicator.classList.remove('text-orange-500');
                    textLengthIndicator.classList.add('text-gray-500');
                }

                console.log(`å­—ç¬¦æ•°é‡å·²æ›´æ–°: ${length} å­—ç¬¦`); // è°ƒè¯•ä¿¡æ¯
            }

            // åŠ è½½ä¸Šæ¬¡ä½¿ç”¨çš„ Prompt URL
            try {
                const savedUrl = localStorage.getItem(LAST_URL_KEY);
                if (savedUrl) {
                    inputPromptAudioUrl.value = savedUrl;
                }
            } catch (e) {
                console.warn("æ— æ³•è®¿é—® localStorage:", e);
            }

            try {
                const savePromptUrl = () => {
                    const val = inputPromptAudioUrl.value || '';
                    localStorage.setItem(LAST_URL_KEY, val);
                };
                inputPromptAudioUrl.addEventListener('change', savePromptUrl);
                inputPromptAudioUrl.addEventListener('blur', savePromptUrl);
            } catch (e) { }

            // ç»‘å®šç”ŸæˆæŒ‰é’®ç‚¹å‡»äº‹ä»¶
            console.log('ç”ŸæˆæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨å·²ç»‘å®š');
            generateBtn.addEventListener('click', async () => {
                if (window.CURRENT_VERSION === '1.1') {
                    await handleAsyncGeneration();
                } else {
                    await handleSyncGeneration();
                }
            });

            async function handleSyncGeneration() {
                console.log('ç”ŸæˆæŒ‰é’®è¢«ç‚¹å‡»ï¼Œå¼€å§‹å¤„ç† (v1.0 Sync)...');
                // è·å–è¾“å…¥å€¼
                let text = inputText.value;
                const promptAudioUrl = inputPromptAudioUrl.value;
                const promptText = inputPromptText.value;

                // ç®€å•çš„æ ¡éªŒ
                if (!text || !promptAudioUrl) {
                    showError("\"è¦è½¬æ¢çš„æ–‡æœ¬\"å’Œ\"Prompt Audio URL\"å­—æ®µä¸èƒ½ä¸ºç©ºã€‚");
                    return;
                }

                // æ–‡æœ¬é•¿åº¦æç¤º (æ— å­—ç¬¦é™åˆ¶ï¼Œä»…ä½œæé†’)
                if (text.length > 2000) {
                    console.warn(`æ–‡æœ¬è¾ƒé•¿ (${text.length} å­—ç¬¦)ï¼Œç”Ÿæˆå¯èƒ½éœ€è¦æ›´å¤šæ—¶é—´`);
                }

                // ä¿å­˜ URL
                try {
                    localStorage.setItem(LAST_URL_KEY, promptAudioUrl);
                } catch (e) {
                    console.warn("æ— æ³•ä¿å­˜ URL åˆ° localStorage:", e);
                }

                // è®¾ç½® UI ä¸ºåŠ è½½ä¸­
                setLoading(true);
                audioContainer.classList.add('hidden'); // éšè—æ—§éŸ³é¢‘

                // å¼€å§‹è®¡æ—¶
                let startTime = Date.now();
                let timerInterval;

                // æ›´æ–°æŒ‰é’®å†…çš„ç­‰å¾…æ—¶é—´æ˜¾ç¤º
                const updateWaitTime = () => {
                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                    btnStatusText.textContent = `æ­£åœ¨ç”Ÿæˆ... å·²ç­‰å¾… ${elapsedSeconds} ç§’`;
                };

                // ç«‹å³æ›´æ–°ä¸€æ¬¡æŒ‰é’®çŠ¶æ€æ–‡æœ¬
                updateWaitTime();
                timerInterval = setInterval(updateWaitTime, 1000); // æ¯ç§’æ›´æ–°ä¸€æ¬¡

                // æ„å»ºè¯·æ±‚ä½“
                const payload = {
                    input: text,
                    model: "IndexTTS-2", // ç¡¬ç¼–ç 
                    voice: "alloy", // ç¡¬ç¼–ç 
                    prompt_audio_url: promptAudioUrl
                };

                // å¦‚æœæœ‰ prompt_textï¼Œæ‰æ·»åŠ åˆ° payload
                if (promptText) {
                    payload.prompt_text = promptText;
                }

                try {
                    // è°ƒè¯•ä¿¡æ¯
                    const headers = { 'Content-Type': 'application/json' };
                    if (API_KEY) { headers['Authorization'] = `Bearer ${API_KEY}`; }

                    // å‘é€ API è¯·æ±‚
                    console.log('æ­£åœ¨å‘é€APIè¯·æ±‚ (Sync)...');
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(payload)
                    });

                    // æ£€æŸ¥å“åº”çŠ¶æ€
                    if (!response.ok) {
                        let errorDetails = `çŠ¶æ€: ${response.status} ${response.statusText}`;
                        try {
                            const errorJson = await response.json();
                            errorDetails += ` - ${errorJson.error?.message || 'æœªçŸ¥é”™è¯¯'}`;
                        } catch (e) { }
                        btnStatusText.textContent = "è¯·æ±‚å¤±è´¥...";
                        throw new Error(`API è¯·æ±‚å¤±è´¥ï¼Œ${errorDetails}ã€‚è¯·æ£€æŸ¥æ‚¨çš„è¾“å…¥æˆ– API Keyã€‚`);
                    }

                    // å¤„ç†æˆåŠŸçš„å“åº” (åº”è¯¥æ˜¯éŸ³é¢‘æµ)
                    const audioBlob = await response.blob();
                    if (!audioBlob.type.startsWith('audio/')) {
                        throw new Error(`API æœªè¿”å›æœ‰æ•ˆçš„éŸ³é¢‘ã€‚æ”¶åˆ°ç±»å‹: ${audioBlob.type}ã€‚è¯·æ£€æŸ¥ API Key å’Œè¾“å…¥ã€‚`);
                    }

                    // åˆ›å»º Blob URL å¹¶è®¾ç½®ç»™æ’­æ”¾å™¨
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayer.src = audioUrl;
                    audioContainer.classList.remove('hidden'); // æ˜¾ç¤ºæ’­æ”¾å™¨

                    // è®¡ç®—ç”Ÿæˆç”¨æ—¶
                    const endTime = Date.now();
                    const totalTime = Math.floor((endTime - startTime) / 1000);
                    computeTimeDisplay.textContent = `ç”Ÿæˆç”¨æ—¶: ${totalTime} ç§’`;

                    // æ›´æ–°æŒ‰é’®å†…çš„çŠ¶æ€æ¶ˆæ¯
                    if (btnStatusContainer && btnStatusText) {
                        btnStatusText.textContent = "è¯­éŸ³ç”ŸæˆæˆåŠŸï¼";
                    }

                    // å­˜å‚¨éŸ³é¢‘URLå’Œæ—¶é—´æˆ³åˆ°localStorage
                    storeAudioUrl(audioUrl);

                } catch (error) {
                    console.error('API è¯·æ±‚å‡ºé”™:', error);
                    let friendlyError = error.message;
                    if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                        friendlyError = "è¯·æ±‚å¤±è´¥ã€‚è¿™å¾ˆå¯èƒ½æ˜¯ CORS è·¨åŸŸé”™è¯¯ã€‚è¯·æŒ‰ F12 æ‰“å¼€å¼€å‘è€…æ§åˆ¶å°æŸ¥çœ‹ç½‘ç»œè¯·æ±‚ã€‚";
                    }
                    showError(friendlyError);
                } finally {
                    clearInterval(timerInterval);
                    waitTimeDisplay.classList.add('hidden');
                    setLoading(false);
                }
            }

            // --- v1.1 å¼‚æ­¥ç”Ÿæˆé€»è¾‘ ---

            async function handleAsyncGeneration() {
                console.log('ç”ŸæˆæŒ‰é’®è¢«ç‚¹å‡»ï¼Œå¼€å§‹å¤„ç† (v1.1 Async)...');

                // 1. è·å–è¾“å…¥
                let text = inputText.value;
                const promptAudioUrl = inputPromptAudioUrl.value;
                const promptText = inputPromptText.value;
                const remark = document.getElementById('input-remark').value; // è·å–å¤‡æ³¨

                if (!text || !promptAudioUrl) {
                    showError("\"è¦è½¬æ¢çš„æ–‡æœ¬\"å’Œ\"Prompt Audio URL\"å­—æ®µä¸èƒ½ä¸ºç©ºã€‚");
                    return;
                }

                // 2. æ„é€  Payload
                const payload = {
                    inputs: text,
                    model: "IndexTTS-2",
                    voice: "alloy",
                    prompt_audio_url: promptAudioUrl
                };
                if (promptText) payload.prompt_text = promptText;

                try { localStorage.setItem(LAST_URL_KEY, promptAudioUrl); } catch (e) { }

                // 3. UI åé¦ˆ
                setLoading(true);
                btnStatusText.textContent = "æ­£åœ¨æäº¤ä»»åŠ¡...";

                try {
                    // 4. æäº¤ä»»åŠ¡
                    const responseData = await submitAsyncTask(payload);
                    const taskId = responseData.task_id || responseData.id;
                    const upstreamPollUrl = responseData.urls?.get;

                    console.log("Task submitted, ID:", taskId, "Poll URL:", upstreamPollUrl);
                    window.lastSubmittedTaskId = taskId;

                    // 5. å­˜å…¥ DB
                    const newTask = {
                        id: taskId,
                        api_task_id: taskId,
                        full_text: text, // ä¿å­˜å®Œæ•´æ–‡æœ¬ç”¨äºå›å¡«
                        prompt_text: promptText, // ä¿å­˜ prompt text
                        text_preview: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
                        prompt_audio: promptAudioUrl,
                        remark: remark || '', // ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„å¤‡æ³¨
                        status: 'pending',
                        created_at: Date.now(),
                        audio_blob: null,
                        duration: 0
                    };

                    if (window.dbLayer) {
                        await window.dbLayer.saveTask(newTask);
                        console.log("Task saved to DB");
                    }

                    // 6. å¯åŠ¨è½®è¯¢
                    startPolling(taskId, upstreamPollUrl);

                    // 7. æ›´æ–° UI
                    renderTaskList();

                    // æ¢å¤æŒ‰é’®çŠ¶æ€ (å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œæäº¤æˆåŠŸå³å¯æ¢å¤æŒ‰é’®ï¼Œæ— éœ€ç­‰å¾…ç”Ÿæˆå®Œæˆ)
                    btnStatusText.textContent = "ä»»åŠ¡å·²æäº¤";
                    setTimeout(() => setLoading(false), 1000);

                } catch (error) {
                    console.error("Async submission failed:", error);
                    showError("æäº¤ä»»åŠ¡å¤±è´¥: " + error.message);
                    setLoading(false);
                }
            }

            async function submitAsyncTask(payload) {
                // æ„é€ å¼‚æ­¥ API URL
                // å¦‚æœ PROD_DEFAULT_API_URL æŒ‡å‘ worker (https://.../audio/speech)ï¼Œåˆ™æ›¿æ¢ä¸º /async/audio/speech
                // å¦‚æœæ˜¯ç›´æ¥æŒ‡å‘ gitee (https://ai.gitee.com/v1/audio/speech)ï¼Œåˆ™æ›¿æ¢ä¸º /async/audio/speech
                // ä½†è€ƒè™‘åˆ° worker é€»è¾‘ï¼Œæˆ‘ä»¬ç»Ÿä¸€ä½¿ç”¨ API_URL (å®ƒå¯èƒ½å·²ç»è¢« override)

                let asyncApiUrl = API_URL.replace('/audio/speech', '/async/audio/speech');

                // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœ API_URL å·²ç»æ˜¯ async çš„ (æå°‘æƒ…å†µ)ï¼Œæˆ–è€…å¦‚æœ API_URL æ˜¯æ ¹è·¯å¾„
                // ç®€å•èµ·è§ï¼Œå‡è®¾ API_URL æ€»æ˜¯ä»¥ /audio/speech ç»“å°¾
                if (!asyncApiUrl.includes('/async/audio/speech')) {
                    // å¦‚æœæ›¿æ¢å¤±è´¥ (ä¾‹å¦‚ API_URL æ˜¯æ ¹è·¯å¾„)ï¼Œæ‰‹åŠ¨æ‹¼æ¥
                    asyncApiUrl = API_URL.replace(/\/+$/, '') + '/async/audio/speech';
                }

                const headers = { 'Content-Type': 'application/json' };
                // å¼‚æ­¥æ¥å£é€šå¸¸ä¹Ÿéœ€è¦é‰´æƒï¼Œå¦‚æœé€šè¿‡ workerï¼Œworker ä¼šæ³¨å…¥ key
                // å¦‚æœç›´è¿ï¼Œéœ€è¦ API_KEY
                if (API_KEY) { headers['Authorization'] = `Bearer ${API_KEY}`; }

                console.log("Submitting to:", asyncApiUrl);

                const response = await fetch(asyncApiUrl, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    throw new Error(err.message || `HTTP ${response.status}`);
                }

                const result = await response.json();
                // å‡è®¾è¿”å›ç»“æ„ { task_id: "..." }
                if (!result.task_id && !result.id) {
                    throw new Error("Invalid response: missing task_id");
                }
                return result;
            }

            async function autoRegenerateTask(oldTaskId) {
                console.log(`Auto-regenerating task ${oldTaskId}...`);
                try {
                    // 1. è·å–æ—§ä»»åŠ¡æ•°æ®
                    let oldTask = null;
                    if (window.dbLayer) {
                        const tasks = await window.dbLayer.getTasks();
                        oldTask = tasks.find(t => t.id === oldTaskId);
                    }

                    if (!oldTask) {
                        console.error("Old task not found in DB, cannot regenerated.");
                        return;
                    }

                    // 2. æ„é€  Payload
                    // æ³¨æ„ï¼šç”±äºä¹‹å‰ saveTask å¯èƒ½æ²¡å­˜ input ä¸‹å…¨æ–‡ï¼Œè¿™é‡Œä¼˜å…ˆç”¨ full_textï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨ text_preview (å¯èƒ½æœ‰é£é™©)
                    // åœ¨ä¹‹å‰çš„ä»£ç åˆ†æä¸­ï¼Œæˆ‘ä»¬å‘ç° saveTask ç¡®å®ä¿å­˜äº† full_text (è§ line 509: full_text: text)
                    const payload = {
                        inputs: oldTask.full_text || oldTask.text_preview,
                        model: "IndexTTS-2",
                        voice: "alloy",
                        prompt_audio_url: oldTask.prompt_audio
                    };
                    if (oldTask.prompt_text) payload.prompt_text = oldTask.prompt_text;

                    // 3. æäº¤æ–°ä»»åŠ¡
                    if (btnStatusText) btnStatusText.textContent = "æ—§ä»»åŠ¡ä¸¢å¤±ï¼Œè‡ªåŠ¨é‡è¯•ä¸­...";
                    const responseData = await submitAsyncTask(payload);
                    const newTaskId = responseData.task_id || responseData.id;
                    const upstreamPollUrl = responseData.urls?.get;

                    console.log(`Auto-regenerated: ${oldTaskId} -> ${newTaskId}`);

                    // 4. æ›´æ–° DB
                    if (window.dbLayer) {
                        // åˆ é™¤æ—§ä»»åŠ¡
                        await window.dbLayer.deleteTask(oldTaskId);

                        // åˆ›å»ºæ–°ä»»åŠ¡ (å¤åˆ¶æ—§ä»»åŠ¡çš„å…ƒæ•°æ®)
                        const newTask = {
                            ...oldTask,
                            id: newTaskId,
                            api_task_id: newTaskId,
                            status: 'pending',
                            created_at: Date.now(), // æ›´æ–°åˆ›å»ºæ—¶é—´
                            error_message: null // æ¸…é™¤é”™è¯¯ä¿¡æ¯
                        };
                        await window.dbLayer.saveTask(newTask);
                    }

                    // 5. å¯åŠ¨å¯¹æ–°ä»»åŠ¡çš„è½®è¯¢
                    startPolling(newTaskId, upstreamPollUrl);

                    // 6. åˆ·æ–°åˆ—è¡¨
                    renderTaskList();

                } catch (e) {
                    console.error("Auto-regenerate failed:", e);
                    await markFailed(oldTaskId, "è‡ªåŠ¨é‡è¯•å¤±è´¥: " + e.message);
                }
            }

            // è½®è¯¢ç®¡ç† map (å·²ç§»è‡³é¡¶éƒ¨)
            const TIMEOUT_SECONDS = 600;

            async function startPolling(taskId, upstreamPollUrl) {
                if (activePolls.has(taskId)) return;
                activePolls.add(taskId);
                let startedAtMs = null;

                // ä½¿ç”¨å…¨å±€ markFailed(taskId, reason)

                const workerBase = API_URL.replace(/\/audio\/speech\/?$/, '');
                let pollId = taskId;
                let preferPlural = false;
                if (upstreamPollUrl) {
                    try {
                        const urlObj = new URL(upstreamPollUrl);
                        const idMatch = urlObj.pathname.match(/\/tasks?\/([^/]+)/);
                        if (idMatch && idMatch[1]) {
                            pollId = idMatch[1];
                            preferPlural = /\/tasks\//.test(urlObj.pathname);
                        }
                    } catch (e) { }
                }
                const pollUrlSingular = `${workerBase}/task/${pollId}`;
                const pollUrlPlural = `${workerBase}/tasks/${pollId}`;
                let pollUrl = preferPlural ? pollUrlPlural : pollUrlSingular;
                let toggledRoute = false;

                const maxAttempts = 60;
                let attempts = 0;
                let badRequestCount = 0;
                let notFoundCount = 0;
                let taskNotFoundCount = 0;

                const poll = async () => {
                    if (!activePolls.has(taskId)) return; // åœæ­¢è½®è¯¢
                    // è§£æä»»åŠ¡èµ·å§‹æ—¶é—´ï¼ˆä¸€æ¬¡æ€§ï¼‰
                    if (startedAtMs == null) {
                        try {
                            if (window.dbLayer) {
                                const tasks = await window.dbLayer.getTasks();
                                const existing = tasks.find(t => t.id === taskId);
                                if (existing) {
                                    startedAtMs = existing.started_at || existing.created_at || Date.now();
                                } else {
                                    startedAtMs = Date.now();
                                }
                            } else {
                                startedAtMs = Date.now();
                            }
                        } catch (e) {
                            startedAtMs = Date.now();
                        }
                    }

                    // è¶…æ—¶æ§åˆ¶ï¼šè¶…è¿‡ 600 ç§’ç›´æ¥æ ‡è®°å¤±è´¥å¹¶åœæ­¢
                    if (Date.now() - startedAtMs > TIMEOUT_SECONDS * 1000) {
                        await markFailed(taskId, "ç”Ÿæˆè¶…æ—¶ï¼ˆ>600ç§’ï¼‰ï¼Œè¯·é‡æ–°ç”Ÿæˆ");
                        return;
                    }

                    attempts++;

                    try {
                        console.log(`Polling task ${taskId}, attempt ${attempts}`);
                        const pollHeaders = { 'Accept': 'application/json' };
                        if (API_KEY) { pollHeaders['Authorization'] = `Bearer ${API_KEY}`; }
                        const response = await fetch(pollUrl, { headers: pollHeaders });
                        if (!response.ok) {
                            if (response.status === 400 || response.status === 404) {
                                // ç§»é™¤è‡ªåŠ¨åˆ‡æ¢è·¯å¾„çš„é€»è¾‘ï¼Œå¼ºåˆ¶ä½¿ç”¨å•æ•°è·¯å¾„
                                if (response.status === 400) {
                                    let isTaskNotFoundError = false;
                                    // å°è¯•è¯»å–å¹¶æ‰“å°é”™è¯¯è¯¦æƒ…
                                    try {
                                        const errText = await response.text();
                                        console.error(`Polling 400 Error Body:`, errText);
                                        if (errText.includes("ä»»åŠ¡ä¸å­˜åœ¨")) {
                                            isTaskNotFoundError = true;
                                        }
                                    } catch (e) { }

                                    if (isTaskNotFoundError) {
                                        // "ä»»åŠ¡ä¸å­˜åœ¨" è®¡æ•°
                                        taskNotFoundCount++;
                                        console.warn(`Task not found (400), attempt ${taskNotFoundCount}/3...`);

                                        if (taskNotFoundCount >= 3) {
                                            console.warn("Task appears lost. Auto-regenerating...");
                                            activePolls.delete(taskId); // åœæ­¢å½“å‰è½®è¯¢
                                            await autoRegenerateTask(taskId); // è§¦å‘è‡ªåŠ¨é‡æ–°æäº¤
                                            return;
                                        }
                                    } else {
                                        badRequestCount++;
                                        if (badRequestCount >= 3) {
                                            await markFailed(taskId, "ä»»åŠ¡æŸ¥è¯¢æ¥å£è¿”å› 400ï¼ˆè¯·æŸ¥çœ‹æ§åˆ¶å°é”™è¯¯è¯¦æƒ…ï¼‰");
                                            return;
                                        }
                                    }
                                }
                                if (response.status === 404) {
                                    notFoundCount++;
                                    if (notFoundCount >= 3) {
                                        await markFailed(taskId, "ä»»åŠ¡æŸ¥è¯¢æ¥å£è¿”å› 404ï¼ˆä»»åŠ¡ä¸å­˜åœ¨æˆ–è·¯å¾„é”™è¯¯ï¼‰");
                                        return;
                                    }
                                }
                            }
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const result = await response.json();
                        const status = result.status; // success, failed, running?

                        console.log(`Task ${taskId} status: ${status}`);

                        if (status === 'success') {
                            // ä»»åŠ¡å®Œæˆ
                            activePolls.delete(taskId);

                            // ä¸‹è½½éŸ³é¢‘æ–‡ä»¶
                            const fileUrl = result.output?.file_url;
                            let audioBlob = null;
                            if (fileUrl) {
                                // å°è¯•é€šè¿‡ worker ä»£ç†ä¸‹è½½ (å¦‚æœ fileUrl æ˜¯è·¨åŸŸçš„)
                                // æˆ–è€…ç›´æ¥ fetch (å¦‚æœæ”¯æŒ CORS)
                                // Gitee è¿”å›çš„ file_url é€šå¸¸æ˜¯ OSS åœ°å€ï¼Œå¯èƒ½éœ€è¦ä»£ç†
                                // è¿™é‡Œå…ˆå°è¯•ç›´æ¥ fetch
                                const audioRes = await fetch(fileUrl);
                                if (!audioRes.ok) {
                                    await markFailed(taskId, "éŸ³é¢‘ä¸‹è½½å¤±è´¥ HTTP " + audioRes.status);
                                    return;
                                }
                                audioBlob = await audioRes.blob();
                            }

                            // æ›´æ–° DB
                            if (window.dbLayer) {
                                // å…ˆè·å–æ—§ä»»åŠ¡ä»¥ä¿ç•™å…¶ä»–å­—æ®µ
                                // ç®€åŒ–ï¼šç›´æ¥ update
                                // éœ€è¦æŠŠ blob å­˜å…¥
                                const task = {
                                    id: taskId,
                                    status: 'success',
                                    audio_blob: audioBlob,
                                    // audio_url: audioBlob ? URL.createObjectURL(audioBlob) : null, // ä¸å­˜URLï¼ŒåŠ¨æ€ç”Ÿæˆ
                                    duration: ((result.completed_at || 0) - (result.started_at || 0)) / 1000
                                };
                                // è¯»å–ç°æœ‰ä»»åŠ¡
                                const tasks = await window.dbLayer.getTasks();
                                const existing = tasks.find(t => t.id === taskId);
                                if (existing) {
                                    Object.assign(existing, task);
                                    await window.dbLayer.saveTask(existing);
                                }
                            }

                            renderTaskList();

                            // å¦‚æœæ˜¯å½“å‰åˆšåˆšæäº¤çš„ä»»åŠ¡ï¼Œä¹Ÿå¯ä»¥ç›´æ¥æ˜¾ç¤ºåœ¨ä¸»æ’­æ”¾å™¨ (å¯é€‰ä¼˜åŒ–)

                        } else if (status === 'failed' || status === 'failure' || status === 'cancelled') {
                            console.error("Task failed, full result:", result); // æ‰“å°å®Œæ•´ç»“æœä»¥ä¾¿è°ƒè¯•

                            let errorMsg = "æœåŠ¡ç«¯è¿”å›å¤±è´¥";
                            // å°è¯•ä»ä¸åŒå­—æ®µæå–é”™è¯¯ä¿¡æ¯
                            if (result.error_message) {
                                errorMsg = result.error_message;
                            } else if (result.error) {
                                if (typeof result.error === 'string') {
                                    errorMsg = result.error;
                                } else if (typeof result.error === 'object') {
                                    errorMsg = result.error.message || JSON.stringify(result.error);
                                }
                            } else if (result.message) {
                                errorMsg = result.message;
                            } else if (result.output && result.output.error) {
                                errorMsg = result.output.error;
                            }

                            await markFailed(taskId, errorMsg);
                        } else {
                            // ç»§ç»­è½®è¯¢
                            if (attempts < maxAttempts) {
                                setTimeout(poll, 5000 + attempts * 500); // çº¿æ€§é€€é¿
                            } else {
                                activePolls.delete(taskId);
                                console.warn(`Task ${taskId} polling timeout`);
                            }
                        }

                    } catch (e) {
                        console.error(`Polling error for ${taskId}:`, e);
                        // å¤±è´¥é‡è¯•ï¼Œä¸ç«‹å³åœæ­¢
                        if (attempts < maxAttempts) {
                            setTimeout(poll, 10000);
                        }
                    }
                };

                poll();
            }

            // å ä½å‡½æ•°ï¼ŒPhase 5 å®ç°
            async function renderTaskList() {
                if (window.CURRENT_VERSION !== '1.1') return;

                const sidebar = document.getElementById('task-sidebar');
                const taskListContainer = document.getElementById('task-list');
                const toggleBtn = document.getElementById('sidebar-toggle-btn');

                if (!sidebar || !taskListContainer) return;

                // æ˜¾ç¤ºæµ®åŠ¨æŒ‰é’®
                if (toggleBtn) toggleBtn.classList.remove('hidden');

                // æ˜¾ç¤ºä¾§è¾¹æ 
                sidebar.classList.remove('hidden');
                setTimeout(() => sidebar.classList.remove('translate-x-full'), 10);

                try {
                    if (!window.dbLayer) return;
                    const tasks = await window.dbLayer.getTasks();

                    taskListContainer.innerHTML = ''; // æ¸…ç©ºåˆ—è¡¨

                    if (tasks.length === 0) {
                        taskListContainer.innerHTML = '<p class="text-center text-gray-400 text-sm mt-10">æš‚æ— å†å²ä»»åŠ¡</p>';
                        return;
                    }

                    tasks.forEach(task => {
                        const card = document.createElement('div');
                        card.className = "bg-gray-50 rounded-lg p-3 border border-gray-200 shadow-sm hover:shadow-md transition-shadow";

                        // çŠ¶æ€å›¾æ ‡å’Œé¢œè‰²
                        let statusIcon = 'â³';
                        let statusClass = 'text-yellow-600';
                        let statusText = 'ç”Ÿæˆä¸­'; // é»˜è®¤ä¸­æ–‡

                        if (task.status === 'success') {
                            statusIcon = 'âœ…';
                            statusClass = 'text-green-600';
                            statusText = 'ç”ŸæˆæˆåŠŸ';
                        } else if (task.status === 'failed') {
                            statusIcon = 'âŒ';
                            statusClass = 'text-red-600';
                            statusText = 'ç”Ÿæˆå¤±è´¥';
                        } else if (task.status === 'cancelled') {
                            statusIcon = 'ğŸš«';
                            statusClass = 'text-gray-600';
                            statusText = 'å·²å–æ¶ˆ';
                        }

                        // æ—¶é—´æ ¼å¼åŒ–
                        const timeStr = new Date(task.created_at).toLocaleTimeString();

                        // æ„å»º HTML
                        let controlsHtml = '';
                        if (task.status === 'success' && task.audio_blob) {
                            if (task.audio_blob instanceof Blob) {
                                if (task.audio_blob.size > 0) {
                                    try {
                                        const audioUrl = URL.createObjectURL(task.audio_blob);
                                        const ext = getAudioExt(task.audio_blob.type);
                                        const safeName = sanitizeRemark(task.remark);
                                        const downloadName = `${safeName || 'speech-' + task.id}${ext}`;
                                        controlsHtml = `
                                            <div class="mt-2 space-y-2">
                                                <audio controls class="w-full h-8" src="${audioUrl}" preload="metadata"></audio>
                                                <a href="${audioUrl}" download="${downloadName}" class="block text-center text-xs text-blue-600 hover:underline">â¬‡ï¸ ä¸‹è½½éŸ³é¢‘</a>
                                            </div>
                                        `;
                                    } catch (e) {
                                        console.error("Create object URL failed:", e);
                                        controlsHtml = `<div class="mt-2 text-xs text-red-500">éŸ³é¢‘æ•°æ®åŠ è½½å¤±è´¥</div>`;
                                    }
                                } else {
                                    console.warn("Empty audio blob (size 0):", task.audio_blob);
                                    controlsHtml = `<div class="mt-2 text-xs text-red-500">éŸ³é¢‘æ•°æ®ä¸ºç©º (0 bytes)</div>`;
                                }
                            } else {
                                console.warn("Invalid audio blob:", task.audio_blob);
                                controlsHtml = `<div class="mt-2 text-xs text-red-500">æ— æ•ˆçš„éŸ³é¢‘æ•°æ®</div>`;
                            }
                        } else if (task.status === 'pending' || task.status === 'running') {
                            // è®¡ç®—è€—æ—¶ (æ·»åŠ  dynamic-timer ç±»ä»¥ä¾¿åç»­ JS åŠ¨æ€æ›´æ–°)
                            const elapsed = Math.floor((Date.now() - task.created_at) / 1000);
                            controlsHtml = `<div class="mt-2 text-xs text-gray-500 text-center dynamic-timer" data-start-time="${task.created_at}">å·²è€—æ—¶: ${elapsed}s</div>`;
                        } else if (task.status === 'failed' || task.status === 'cancelled') {
                            // å¤±è´¥çŠ¶æ€ä¸‹æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                            controlsHtml = `<div class="mt-2 text-xs text-red-500 break-words">${task.error_message || 'æœªçŸ¥é”™è¯¯'}</div>`;
                        }

                        // é‡æ–°ç”ŸæˆæŒ‰é’® (æ‰€æœ‰çŠ¶æ€éƒ½æ˜¾ç¤ºï¼Œæ–¹ä¾¿é‡è¯•æˆ–å†æ¬¡ç”Ÿæˆ)
                        const regenBtnHtml = `
                            <button onclick="window.regenerateTask('${task.id}')" class="mt-2 w-full text-xs bg-white border border-gray-300 text-gray-600 py-1 rounded hover:bg-gray-100 transition">
                                ğŸ”„ é‡æ–°ç”Ÿæˆ / å›å¡«å‚æ•°
                            </button>
                            <button onclick="window.quickRegenerateTask('${task.id}')" class="mt-2 w-full text-xs bg-blue-600 text-white py-1 rounded hover:bg-blue-700 transition">
                                âš¡ ä¸€é”®é‡æ–°ç”Ÿæˆ
                            </button>
                        `;

                        card.innerHTML = `
                            <div class="flex justify-between items-center mb-2">
                                <div class="flex items-center">
                                    <input type="checkbox" class="task-checkbox mr-2 rounded border-gray-300 text-blue-600 focus:ring-blue-500" value="${task.id}" onchange="window.updateBulkDeleteState()">
                                    <span class="${statusClass} font-bold text-sm">${statusIcon} ${statusText}</span>
                                </div>
                                <div class="flex items-center">
                                    <span class="text-xs text-gray-400 mr-2">${timeStr}</span>
                                    <button onclick="window.deleteTask('${task.id}')" class="text-gray-400 hover:text-red-500 transition-colors p-1 rounded hover:bg-red-50" title="åˆ é™¤ä»»åŠ¡">
                                        ğŸ—‘ï¸
                                    </button>
                                </div>
                            </div>
                            <div class="flex justify-between items-start mb-2">
                                <div class="text-xs text-gray-700 break-words line-clamp-2 flex-1 mr-2" title="${task.text_preview || ''}">
                                    ${task.text_preview || 'æ— æ–‡æœ¬é¢„è§ˆ'}
                                </div>
                                <button onclick="window.copyTaskText('${task.id}')" class="text-xs text-blue-500 hover:text-blue-700 whitespace-nowrap" title="å¤åˆ¶å®Œæ•´æ–‡æœ¬">
                                    ğŸ“‹ å¤åˆ¶
                                </button>
                            </div>
                            <input type="text" 
                                class="w-full text-xs p-1 border border-gray-200 rounded mb-2 focus:outline-none focus:border-blue-400" 
                                placeholder="æ·»åŠ å¤‡æ³¨..." 
                                value="${task.remark || ''}"
                                onblur="window.updateTaskRemark('${task.id}', this.value)"
                            >
                            ${controlsHtml}
                            ${regenBtnHtml}
                        `;

                        taskListContainer.appendChild(card);
                    });

                } catch (e) {
                    console.error("Render task list error:", e);
                }
            }

            // æš´éœ²ç»™å…¨å±€ä»¥ä¾¿ HTML onclick è°ƒç”¨
            window.copyTaskText = async (taskId) => {
                try {
                    const tasks = await window.dbLayer.getTasks();
                    const task = tasks.find(t => t.id === taskId);
                    if (!task || !task.full_text) {
                        alert("æ— æ³•è·å–å®Œæ•´æ–‡æœ¬");
                        return;
                    }
                    await navigator.clipboard.writeText(task.full_text);

                    // ç®€å•çš„è§†è§‰åé¦ˆ
                    const btn = document.activeElement;
                    if (btn) {
                        const originalText = btn.innerHTML;
                        btn.innerHTML = 'âœ… å·²å¤åˆ¶';
                        setTimeout(() => btn.innerHTML = originalText, 1500);
                    }
                } catch (e) {
                    console.error("Copy failed:", e);
                    alert("å¤åˆ¶å¤±è´¥: " + e.message);
                }
            };

            window.regenerateTask = async (taskId) => {
                try {
                    const tasks = await window.dbLayer.getTasks();
                    const task = tasks.find(t => t.id === taskId);
                    if (!task) return;

                    // è·å–åŸå§‹å‚æ•° (æˆ‘ä»¬éœ€è¦åœ¨ saveTask æ—¶ç¡®ä¿ inputs è¢«ä¿å­˜ï¼Œæˆ–è€…ä» task å¯¹è±¡æ¨æ–­)
                    // ç›®å‰ task å¯¹è±¡é‡Œåªæœ‰ text_preview, prompt_audioã€‚
                    // å®é™…ä¸Šæˆ‘ä»¬éœ€è¦ä¿å­˜å®Œæ•´çš„ inputs åˆ° task å¯¹è±¡é‡Œæ‰èƒ½å›å¡«ã€‚
                    // ç°åœ¨çš„ submitAsyncTask é‡Œçš„ payload æœ‰ input, prompt_audio_url ç­‰ã€‚
                    // ä½†æ˜¯ saveTask çš„æ—¶å€™æ²¡æœ‰å­˜ input å…¨æ–‡ã€‚
                    // è¿™æ˜¯ä¸€ä¸ªå‘ç°çš„é—®é¢˜ã€‚æˆ‘ä»¬éœ€è¦ä¿®æ”¹ saveTask çš„é€»è¾‘ï¼ŒæŠŠå®Œæ•´ input å­˜è¿›å»ã€‚

                    // å‡è®¾æˆ‘ä»¬ä¿®æ”¹äº† saveTask é€»è¾‘ï¼Œæˆ–è€…ç°åœ¨å…ˆç”¨ partial data
                    // æš‚æ—¶å›å¡« prompt_audio å’Œ text (å¦‚æœ text_preview æ˜¯å®Œæ•´çš„...)
                    // ç”±äº text_preview è¢«æˆªæ–­äº†ï¼Œæ‰€ä»¥å¦‚æœåªå­˜äº† previewï¼Œå°±æ— æ³•å®Œå…¨æ¢å¤ã€‚
                    // **ä¿®æ­£è®¡åˆ’**ï¼šåœ¨ handleAsyncGeneration é‡Œ saveTask æ—¶ï¼Œå­˜å…¥ full_textã€‚

                    if (task.full_text) document.getElementById('input-text').value = task.full_text;
                    if (task.prompt_audio) document.getElementById('input-prompt-audio-url').value = task.prompt_audio;
                    if (task.prompt_text) document.getElementById('input-prompt-text').value = task.prompt_text;
                    const remarkInput = document.getElementById('input-remark');
                    if (remarkInput) remarkInput.value = task.remark || '';

                    // æç¤ºç”¨æˆ·
                    const btn = document.getElementById('generate-btn');
                    btn.focus();
                    // é«˜äº®ä¸€ä¸‹æŒ‰é’®æˆ–è€…æ˜¾ç¤ºæç¤º
                    alert("å‚æ•°å·²å›å¡«ï¼Œè¯·ç‚¹å‡»ç”ŸæˆæŒ‰é’®ã€‚");

                } catch (e) {
                    console.error("Regenerate error:", e);
                }
            };

            window.quickRegenerateTask = async (taskId) => {
                try {
                    const tasks = await window.dbLayer.getTasks();
                    const task = tasks.find(t => t.id === taskId);
                    if (!task) return;
                    const inputTextEl = document.getElementById('input-text');
                    const promptAudioEl = document.getElementById('input-prompt-audio-url');
                    const promptTextEl = document.getElementById('input-prompt-text');
                    const remarkEl = document.getElementById('input-remark');
                    if (inputTextEl) inputTextEl.value = task.full_text || '';
                    if (promptAudioEl) promptAudioEl.value = task.prompt_audio || '';
                    if (promptTextEl) promptTextEl.value = task.prompt_text || '';
                    if (remarkEl) remarkEl.value = task.remark || '';
                    await handleAsyncGeneration();
                } catch (e) {
                    console.error('Quick regenerate error:', e);
                }
            };

            window.updateTaskRemark = async (taskId, newRemark) => {
                try {
                    const tasks = await window.dbLayer.getTasks();
                    const task = tasks.find(t => t.id === taskId);
                    if (task) {
                        task.remark = newRemark;
                        await window.dbLayer.saveTask(task);
                    }
                } catch (e) {
                    console.error("Update remark error:", e);
                }
            };

            // --- è¾…åŠ©å‡½æ•° ---

            function setLoading(isLoading) {
                if (isLoading) {
                    generateBtn.disabled = true;
                    btnText.classList.add('hidden');
                    btnStatusContainer.classList.remove('hidden');
                } else {
                    generateBtn.disabled = false;
                    btnText.classList.remove('hidden');
                    btnStatusContainer.classList.add('hidden');
                    // æ¸…é™¤çŠ¶æ€æ–‡æœ¬
                    btnStatusText.textContent = '';
                }
            }

            function showError(message) {
                statusMsg.textContent = message;
                statusMsg.className = "text-center text-red-500 h-5";
            }
            async function markFailed(taskId, reason) {
                try {
                    activePolls.delete(taskId);
                    if (window.dbLayer) {
                        const tasks = await window.dbLayer.getTasks();
                        const existing = tasks.find(t => t.id === taskId);
                        if (existing) {
                            existing.status = 'failed';
                            existing.error_message = reason;
                            await window.dbLayer.saveTask(existing);
                        }
                    }
                    renderTaskList();
                    if (window.lastSubmittedTaskId === taskId) {
                        showError("ä»»åŠ¡å¤±è´¥: " + (reason || "æœªçŸ¥é”™è¯¯"));
                        setLoading(false);
                        if (btnStatusText) { btnStatusText.textContent = "ä»»åŠ¡å¤±è´¥"; }
                    }
                } catch (e) {
                    console.error('markFailed error:', e);
                }
            }

            function sanitizeRemark(remark) {
                if (typeof remark !== 'string') return null;
                let s = remark.trim();
                s = s.replace(/[\x00-\x1F]/g, '');
                s = s.replace(/[\\\/:*?"<>|]/g, '-');
                s = s.replace(/\s+/g, ' ');
                if (!s) return null;
                if (s.length > 64) s = s.slice(0, 64);
                return s;
            }

            function getAudioExt(blobType) {
                if (typeof blobType === 'string' && blobType.toLowerCase().includes('wav')) return '.wav';
                return '.mp3';
            }

            // å­˜å‚¨éŸ³é¢‘URLå’Œæ—¶é—´æˆ³
            function storeAudioUrl(audioUrl) {
                try {
                    // è·å–ç°æœ‰éŸ³é¢‘URLåˆ—è¡¨
                    const audioUrls = JSON.parse(localStorage.getItem(AUDIO_URLS_KEY) || '[]');

                    // æ·»åŠ æ–°çš„éŸ³é¢‘URLå’Œæ—¶é—´æˆ³
                    audioUrls.push({
                        url: audioUrl,
                        timestamp: Date.now()
                    });

                    // ä¿å­˜åˆ°localStorage
                    localStorage.setItem(AUDIO_URLS_KEY, JSON.stringify(audioUrls));
                } catch (e) {
                    console.warn("æ— æ³•å­˜å‚¨éŸ³é¢‘URL:", e);
                }
            }

            // æ¸…ç†è¿‡æœŸçš„éŸ³é¢‘URL
            function cleanupExpiredAudioUrls() {
                try {
                    // è·å–ç°æœ‰éŸ³é¢‘URLåˆ—è¡¨
                    const audioUrls = JSON.parse(localStorage.getItem(AUDIO_URLS_KEY) || '[]');
                    const now = Date.now();
                    const validAudioUrls = [];

                    // éå†æ£€æŸ¥æ¯ä¸ªéŸ³é¢‘URLæ˜¯å¦è¿‡æœŸ
                    for (const audioItem of audioUrls) {
                        if (now - audioItem.timestamp < AUDIO_EXPIRY_TIME) {
                            // æœªè¿‡æœŸï¼Œä¿ç•™
                            validAudioUrls.push(audioItem);
                        } else {
                            // å·²è¿‡æœŸï¼Œé‡Šæ”¾URLå¯¹è±¡å¹¶ä»åˆ—è¡¨ä¸­ç§»é™¤
                            try {
                                URL.revokeObjectURL(audioItem.url);
                                console.log('å·²æ¸…ç†è¿‡æœŸéŸ³é¢‘URL:', audioItem.url);
                            } catch (e) {
                                console.warn('æ¸…ç†éŸ³é¢‘URLå¤±è´¥:', e);
                            }
                        }
                    }

                    // ä¿å­˜æœ‰æ•ˆéŸ³é¢‘URLåˆ—è¡¨
                    localStorage.setItem(AUDIO_URLS_KEY, JSON.stringify(validAudioUrls));
                } catch (e) {
                    console.warn("æ¸…ç†è¿‡æœŸéŸ³é¢‘URLå¤±è´¥:", e);
                }
            }

            // åˆå§‹åŒ–æ—¶æ£€æŸ¥å¹¶æ¸…ç†è¿‡æœŸéŸ³é¢‘URL
            cleanupExpiredAudioUrls();

            // è®¾ç½®å®šæœŸæ¸…ç†ä»»åŠ¡ï¼ˆæ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡ï¼‰
            setInterval(cleanupExpiredAudioUrls, 60 * 60 * 1000);

            // å…¨å±€å®šæ—¶å™¨ï¼šæ›´æ–°ä»»åŠ¡åˆ—è¡¨ä¸­çš„åŠ¨æ€è®¡æ—¶å™¨
            setInterval(() => {
                const timers = document.querySelectorAll('.dynamic-timer');
                timers.forEach(timer => {
                    const startTime = parseInt(timer.getAttribute('data-start-time'));
                    if (startTime) {
                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                        timer.textContent = `å·²è€—æ—¶: ${elapsed}s`;
                    }
                });
            }, 1000);

            // --- Custom Modal Logic ---
            let pendingDeleteId = null;
            let isBulkDelete = false;

            window.openDeleteModal = (msg) => {
                const modal = document.getElementById('delete-modal');
                const msgEl = document.getElementById('delete-modal-msg');
                if (modal && msgEl) {
                    msgEl.textContent = msg;
                    modal.classList.remove('hidden');
                }
            };

            window.closeDeleteModal = () => {
                const modal = document.getElementById('delete-modal');
                if (modal) modal.classList.add('hidden');
                pendingDeleteId = null;
                isBulkDelete = false;
            };

            window.performDelete = async () => {
                // Capture state before closing modal (which clears these variables)
                const idToDelete = pendingDeleteId;
                const bulkMode = isBulkDelete;

                window.closeDeleteModal();

                try {
                    console.log("Performing delete. Bulk:", bulkMode, "ID:", idToDelete);
                    if (bulkMode) {
                        const checkedBoxes = document.querySelectorAll('.task-checkbox:checked');
                        const ids = Array.from(checkedBoxes).map(cb => cb.value);
                        if (window.dbLayer) {
                            for (const id of ids) {
                                await window.dbLayer.deleteTask(id);
                            }
                            await renderTaskList();
                            const selectAllCheckbox = document.getElementById('select-all-tasks');
                            if (selectAllCheckbox) {
                                selectAllCheckbox.checked = false;
                                selectAllCheckbox.indeterminate = false;
                            }
                            window.updateBulkDeleteState();
                        }
                    } else if (idToDelete) {
                        if (window.dbLayer) {
                            await window.dbLayer.deleteTask(idToDelete);
                            await renderTaskList();
                            window.updateBulkDeleteState();
                        }
                    } else {
                        console.warn("No ID to delete and not bulk mode");
                    }
                } catch (e) {
                    console.error("Delete operation failed:", e);
                    alert("æ“ä½œå¤±è´¥: " + e.message);
                }
            };

            // æš´éœ²ç»™å…¨å±€çš„åˆ é™¤å‡½æ•°
            window.deleteTask = (taskId) => {
                console.log("Delete requested for:", taskId);
                pendingDeleteId = taskId;
                isBulkDelete = false;
                window.openDeleteModal('ç¡®å®šè¦åˆ é™¤è¿™æ¡ä»»åŠ¡è®°å½•å—ï¼Ÿ(ä¸ä¼šåˆ é™¤æœåŠ¡ç«¯æ•°æ®)');
            };

            // æ‰¹é‡åˆ é™¤çŠ¶æ€æ›´æ–°
            window.updateBulkDeleteState = () => {
                const checkboxes = document.querySelectorAll('.task-checkbox');
                const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
                const btn = document.getElementById('bulk-delete-btn');
                const selectAll = document.getElementById('select-all-tasks');

                if (btn) btn.disabled = checkedCount === 0;

                if (selectAll) {
                    selectAll.checked = checkboxes.length > 0 && checkedCount === checkboxes.length;
                    selectAll.indeterminate = checkedCount > 0 && checkedCount < checkboxes.length;
                }
            };

            // ç»‘å®šæ‰¹é‡æ“ä½œäº‹ä»¶
            const selectAllCheckbox = document.getElementById('select-all-tasks');
            const bulkDeleteBtn = document.getElementById('bulk-delete-btn');

            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', (e) => {
                    const checked = e.target.checked;
                    document.querySelectorAll('.task-checkbox').forEach(cb => {
                        cb.checked = checked;
                    });
                    window.updateBulkDeleteState();
                });
            }

            if (bulkDeleteBtn) {
                bulkDeleteBtn.addEventListener('click', () => {
                    const checkedBoxes = document.querySelectorAll('.task-checkbox:checked');
                    if (checkedBoxes.length === 0) return;

                    isBulkDelete = true;
                    pendingDeleteId = null;
                    window.openDeleteModal(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${checkedBoxes.length} æ¡ä»»åŠ¡å—ï¼Ÿ`);
                });
            }

        }); // å…³é—­ DOMContentLoaded äº‹ä»¶ç›‘å¬å™¨

    </script>
</body>

</html>